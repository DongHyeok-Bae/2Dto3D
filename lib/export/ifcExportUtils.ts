/**
 * IFC Export Utilities
 * web-ifc 라이브러리를 사용하여 표준 IFC(ISO-10303-21 STEP) 파일을 생성합니다.
 *
 * @module lib/export/ifcExportUtils
 */
'use client'

import * as WebIFC from 'web-ifc'
import type { MasterJSON } from '@/types'

// ==================== Constants ====================

/** mm에서 m로 변환 */
const MM_TO_M = 0.001

/** 기본 벽 높이 (mm) */
const DEFAULT_WALL_HEIGHT = 2700

/** 기본 슬라브 두께 (mm) */
const DEFAULT_SLAB_THICKNESS = 200

/** 기본 공간 높이 (mm) */
const DEFAULT_SPACE_HEIGHT = 2700

// IFC Type Codes (web-ifc에서 export됨)
const {
  IFCPROJECT,
  IFCSITE,
  IFCBUILDING,
  IFCBUILDINGSTOREY,
  IFCWALL,
  IFCWALLSTANDARDCASE,
  IFCSPACE,
  IFCSLAB,
  IFCDOOR,
  IFCWINDOW,
  IFCOPENINGELEMENT,
  IFCOWNERHISTORY,
  IFCPERSON,
  IFCORGANIZATION,
  IFCPERSONANDORGANIZATION,
  IFCAPPLICATION,
  IFCRELAGGREGATES,
  IFCRELCONTAINEDINSPATIALSTRUCTURE,
  IFCLOCALPLACEMENT,
  IFCAXIS2PLACEMENT3D,
  IFCCARTESIANPOINT,
  IFCDIRECTION,
  IFCSHAPEREPRESENTATION,
  IFCPRODUCTDEFINITIONSHAPE,
  IFCEXTRUDEDAREASOLID,
  IFCRECTANGLEPROFILEDEF,
  IFCARBITRARYCLOSEDPROFILEDEF,
  IFCGEOMETRICREPRESENTATIONCONTEXT,
  IFCGEOMETRICREPRESENTATIONSUBCONTEXT,
  IFCUNITASSIGNMENT,
  IFCSIUNIT,
  IFCPOLYLINE,
  IFCLABEL,
  IFCTEXT,
  IFCIDENTIFIER,
  IFCREAL,
  IFCPOSITIVELENGTHMEASURE,
  IFCLENGTHMEASURE,
  IFCPLANEANGLEMEASURE,
  IFCGLOBALLYUNIQUEID,
  IFCBOOLEAN,
} = WebIFC

// ==================== Types ====================

/** IFC 내보내기 옵션 */
export interface IFCExportOptions {
  /** 프로젝트 이름 */
  projectName?: string
  /** 작성자 */
  author?: string
  /** 조직 */
  organization?: string
  /** IFC 스키마 버전 (기본값: IFC4) */
  schema?: 'IFC2X3' | 'IFC4'
}

/** IFC 프로젝트 계층 구조 */
interface IFCBuildingHierarchy {
  projectId: number
  siteId: number
  buildingId: number
  storeyIds: Map<string, number>
}

/** 기하 컨텍스트 */
interface GeometricContexts {
  context3D: number
  bodyContext: number
}

/** 3D 좌표 (MasterJSON에서 사용) */
interface Point3D {
  x: number
  y: number
  z: number
}

// ==================== Main Export Function ====================

/**
 * MasterJSON을 표준 IFC 파일로 내보냅니다.
 *
 * @param masterJSON - 변환할 MasterJSON 데이터
 * @param options - 내보내기 옵션
 * @throws 브라우저가 WebAssembly를 지원하지 않거나 WASM 로딩 실패 시
 */
export async function exportAsIFC(
  masterJSON: MasterJSON,
  options: IFCExportOptions = {}
): Promise<void> {
  // 브라우저 WebAssembly 지원 확인
  if (typeof WebAssembly === 'undefined') {
    throw new Error('이 브라우저는 WebAssembly를 지원하지 않습니다.')
  }

  // 데이터 검증
  validateMasterJSON(masterJSON)

  // web-ifc API 초기화
  const ifcApi = new WebIFC.IfcAPI()

  let modelID: number | undefined

  try {
    // WASM 경로 설정 및 초기화 (절대 URL 사용)
    await ifcApi.Init((path: string, _prefix: string) => {
      if (path.endsWith('.wasm')) {
        return `${window.location.origin}/wasm/${path}`
      }
      return path
    })

    // IFC 모델 생성
    modelID = ifcApi.CreateModel({
      schema: options.schema === 'IFC2X3' ? 'IFC2X3' : 'IFC4',
      name: options.projectName || '2Dto3D Export',
      description: ['Generated by 2D to 3D BIM Converter'],
      authors: [options.author || 'Unknown'],
      organizations: [options.organization || 'Unknown'],
    })

    // 기본 엔티티 생성
    const ownerHistoryId = createOwnerHistory(ifcApi, modelID, options)
    const unitAssignmentId = createUnitAssignment(ifcApi, modelID)
    const contexts = createGeometricContexts(ifcApi, modelID)

    // 프로젝트 계층 구조 생성
    const hierarchy = createProjectHierarchy(
      ifcApi,
      modelID,
      masterJSON,
      ownerHistoryId,
      contexts,
      unitAssignmentId,
      options
    )

    // 슬라브(바닥) 생성
    if (masterJSON.components?.slabs) {
      for (const slab of masterJSON.components.slabs) {
        createSlabEntity(ifcApi, modelID, slab, hierarchy, ownerHistoryId, contexts)
      }
    }

    // 벽 생성
    if (masterJSON.components?.walls) {
      for (const wall of masterJSON.components.walls) {
        createWallEntity(ifcApi, modelID, wall, hierarchy, ownerHistoryId, contexts)
      }
    }

    // 공간 생성
    if (masterJSON.components?.spaces) {
      for (const space of masterJSON.components.spaces) {
        createSpaceEntity(ifcApi, modelID, space, hierarchy, ownerHistoryId, contexts)
      }
    }

    // 문 생성
    if (masterJSON.components?.openings?.doors) {
      for (const door of masterJSON.components.openings.doors) {
        createDoorEntity(ifcApi, modelID, door, hierarchy, ownerHistoryId, contexts)
      }
    }

    // 창문 생성
    if (masterJSON.components?.openings?.windows) {
      for (const window of masterJSON.components.openings.windows) {
        createWindowEntity(ifcApi, modelID, window, hierarchy, ownerHistoryId, contexts)
      }
    }

    // IFC 파일로 저장
    const ifcData = ifcApi.SaveModel(modelID)

    // 파일 다운로드
    downloadIfcFile(ifcData, `model_${Date.now()}.ifc`)

  } catch (error) {
    console.error('IFC Export Error:', error)
    throw error
  } finally {
    // 메모리 정리
    if (modelID !== undefined) {
      try {
        ifcApi.CloseModel(modelID)
      } catch {
        // 모델 종료 실패는 무시
      }
    }
  }
}

// ==================== Validation ====================

/**
 * MasterJSON 데이터 검증
 */
function validateMasterJSON(masterJSON: MasterJSON): void {
  if (!masterJSON) {
    throw new Error('MasterJSON 데이터가 없습니다.')
  }
  if (!masterJSON.levels || masterJSON.levels.length === 0) {
    throw new Error('MasterJSON에 levels 정보가 없습니다.')
  }
  if (!masterJSON.components) {
    throw new Error('MasterJSON에 components 정보가 없습니다.')
  }
}

// ==================== Helper Functions ====================

/**
 * OwnerHistory 엔티티 생성
 */
function createOwnerHistory(
  ifcApi: WebIFC.IfcAPI,
  modelID: number,
  options: IFCExportOptions
): number {
  // Person
  const person = ifcApi.CreateIfcEntity(
    modelID,
    IFCPERSON,
    null, // Id
    ifcApi.CreateIfcType(modelID, IFCLABEL, options.author || 'User'),
    null, null, null, null, null, null
  )
  ifcApi.WriteLine(modelID, person)

  // Organization
  const organization = ifcApi.CreateIfcEntity(
    modelID,
    IFCORGANIZATION,
    null,
    ifcApi.CreateIfcType(modelID, IFCLABEL, options.organization || 'Organization'),
    null, null, null
  )
  ifcApi.WriteLine(modelID, organization)

  // PersonAndOrganization
  const personAndOrg = ifcApi.CreateIfcEntity(
    modelID,
    IFCPERSONANDORGANIZATION,
    person,
    organization,
    null
  )
  ifcApi.WriteLine(modelID, personAndOrg)

  // Application
  const application = ifcApi.CreateIfcEntity(
    modelID,
    IFCAPPLICATION,
    organization,
    ifcApi.CreateIfcType(modelID, IFCLABEL, '1.0.0'),
    ifcApi.CreateIfcType(modelID, IFCLABEL, '2Dto3D BIM Converter'),
    ifcApi.CreateIfcType(modelID, IFCIDENTIFIER, '2Dto3D')
  )
  ifcApi.WriteLine(modelID, application)

  // OwnerHistory
  const timestamp = Math.floor(Date.now() / 1000)
  const ownerHistory = ifcApi.CreateIfcEntity(
    modelID,
    IFCOWNERHISTORY,
    personAndOrg,
    application,
    null, // State
    { type: 3, value: 'READWRITE' }, // ChangeAction enum
    null, // LastModifiedDate
    personAndOrg,
    application,
    timestamp
  )
  ifcApi.WriteLine(modelID, ownerHistory)

  return ownerHistory.expressID
}

/**
 * 단위 설정 생성 (미터 단위)
 */
function createUnitAssignment(ifcApi: WebIFC.IfcAPI, modelID: number): number {
  // Length unit (METRE)
  const lengthUnit = ifcApi.CreateIfcEntity(
    modelID,
    IFCSIUNIT,
    null, // Dimensions
    { type: 3, value: 'LENGTHUNIT' },
    null, // Prefix
    { type: 3, value: 'METRE' }
  )
  ifcApi.WriteLine(modelID, lengthUnit)

  // Area unit (SQUARE_METRE)
  const areaUnit = ifcApi.CreateIfcEntity(
    modelID,
    IFCSIUNIT,
    null,
    { type: 3, value: 'AREAUNIT' },
    null,
    { type: 3, value: 'SQUARE_METRE' }
  )
  ifcApi.WriteLine(modelID, areaUnit)

  // Volume unit (CUBIC_METRE)
  const volumeUnit = ifcApi.CreateIfcEntity(
    modelID,
    IFCSIUNIT,
    null,
    { type: 3, value: 'VOLUMEUNIT' },
    null,
    { type: 3, value: 'CUBIC_METRE' }
  )
  ifcApi.WriteLine(modelID, volumeUnit)

  // Plane angle unit (RADIAN)
  const angleUnit = ifcApi.CreateIfcEntity(
    modelID,
    IFCSIUNIT,
    null,
    { type: 3, value: 'PLANEANGLEUNIT' },
    null,
    { type: 3, value: 'RADIAN' }
  )
  ifcApi.WriteLine(modelID, angleUnit)

  // Unit assignment
  const unitAssignment = ifcApi.CreateIfcEntity(
    modelID,
    IFCUNITASSIGNMENT,
    [lengthUnit, areaUnit, volumeUnit, angleUnit]
  )
  ifcApi.WriteLine(modelID, unitAssignment)

  return unitAssignment.expressID
}

/**
 * 기하 컨텍스트 생성
 */
function createGeometricContexts(
  ifcApi: WebIFC.IfcAPI,
  modelID: number
): GeometricContexts {
  // World coordinate system origin
  const origin = createCartesianPoint(ifcApi, modelID, 0, 0, 0)
  const zAxis = createDirection(ifcApi, modelID, 0, 0, 1)
  const xAxis = createDirection(ifcApi, modelID, 1, 0, 0)

  // World coordinate system
  const worldCS = ifcApi.CreateIfcEntity(
    modelID,
    IFCAXIS2PLACEMENT3D,
    origin,
    zAxis,
    xAxis
  )
  ifcApi.WriteLine(modelID, worldCS)

  // 3D representation context
  const context3D = ifcApi.CreateIfcEntity(
    modelID,
    IFCGEOMETRICREPRESENTATIONCONTEXT,
    ifcApi.CreateIfcType(modelID, IFCLABEL, 'Model'),
    ifcApi.CreateIfcType(modelID, IFCLABEL, 'Model'),
    3, // CoordinateSpaceDimension
    ifcApi.CreateIfcType(modelID, IFCREAL, 1.0E-5), // Precision
    worldCS,
    null // TrueNorth
  )
  ifcApi.WriteLine(modelID, context3D)

  // Body subcontext - ParentContext는 명시적 참조 타입으로 전달해야 함
  const bodyContext = ifcApi.CreateIfcEntity(
    modelID,
    IFCGEOMETRICREPRESENTATIONSUBCONTEXT,
    ifcApi.CreateIfcType(modelID, IFCLABEL, 'Body'),
    ifcApi.CreateIfcType(modelID, IFCLABEL, 'Model'),
    null, null, null, null,
    { type: 5, value: context3D.expressID },  // ParentContext 참조 (type 5 = REF)
    null,
    { type: 3, value: 'MODEL_VIEW' },
    null
  )
  ifcApi.WriteLine(modelID, bodyContext)

  return {
    context3D: context3D.expressID,
    bodyContext: bodyContext.expressID
  }
}

/**
 * 프로젝트 계층 구조 생성 (Project -> Site -> Building -> Storey)
 */
function createProjectHierarchy(
  ifcApi: WebIFC.IfcAPI,
  modelID: number,
  masterJSON: MasterJSON,
  ownerHistoryId: number,
  contexts: GeometricContexts,
  unitAssignmentId: number,
  options: IFCExportOptions
): IFCBuildingHierarchy {
  const ownerHistory = { type: 5, value: ownerHistoryId } // REF type

  // Project
  const project = ifcApi.CreateIfcEntity(
    modelID,
    IFCPROJECT,
    ifcApi.CreateIfcType(modelID, IFCGLOBALLYUNIQUEID, generateGUID()),
    ownerHistory,
    ifcApi.CreateIfcType(modelID, IFCLABEL, options.projectName || '2Dto3D Project'),
    ifcApi.CreateIfcType(modelID, IFCTEXT, 'Generated by 2D to 3D BIM Converter'),
    null, null, null,
    [{ type: 5, value: contexts.context3D }],
    { type: 5, value: unitAssignmentId }
  )
  ifcApi.WriteLine(modelID, project)

  // Site placement
  const sitePlacement = createLocalPlacement(ifcApi, modelID, null, 0, 0, 0)

  // Site
  const site = ifcApi.CreateIfcEntity(
    modelID,
    IFCSITE,
    ifcApi.CreateIfcType(modelID, IFCGLOBALLYUNIQUEID, generateGUID()),
    ownerHistory,
    ifcApi.CreateIfcType(modelID, IFCLABEL, 'Default Site'),
    null, null,
    sitePlacement,
    null,
    { type: 3, value: 'ELEMENT' }, // CompositionType
    null, null, null, null, null
  )
  ifcApi.WriteLine(modelID, site)

  // Building placement
  const buildingPlacement = createLocalPlacement(ifcApi, modelID, sitePlacement, 0, 0, 0)

  // Building
  const building = ifcApi.CreateIfcEntity(
    modelID,
    IFCBUILDING,
    ifcApi.CreateIfcType(modelID, IFCGLOBALLYUNIQUEID, generateGUID()),
    ownerHistory,
    ifcApi.CreateIfcType(modelID, IFCLABEL, 'Default Building'),
    null, null,
    buildingPlacement,
    null,
    { type: 3, value: 'ELEMENT' },
    null, null, null
  )
  ifcApi.WriteLine(modelID, building)

  // Create storeys from levels
  const storeyIds = new Map<string, number>()

  for (const level of masterJSON.levels) {
    const elevation = (level.elevation || 0) * MM_TO_M

    // Storey placement
    const storeyPlacement = createLocalPlacement(ifcApi, modelID, buildingPlacement, 0, 0, elevation)

    // BuildingStorey
    const storey = ifcApi.CreateIfcEntity(
      modelID,
      IFCBUILDINGSTOREY,
      ifcApi.CreateIfcType(modelID, IFCGLOBALLYUNIQUEID, generateGUID()),
      ownerHistory,
      ifcApi.CreateIfcType(modelID, IFCLABEL, level.levelName),
      null, null,
      storeyPlacement,
      null,
      { type: 3, value: 'ELEMENT' },
      ifcApi.CreateIfcType(modelID, IFCLENGTHMEASURE, elevation)
    )
    ifcApi.WriteLine(modelID, storey)

    storeyIds.set(level.levelName, storey.expressID)
  }

  // Create relationships
  // Project -> Site
  createRelAggregates(ifcApi, modelID, ownerHistoryId, 'Project-Site', project.expressID, [site.expressID])

  // Site -> Building
  createRelAggregates(ifcApi, modelID, ownerHistoryId, 'Site-Building', site.expressID, [building.expressID])

  // Building -> Storeys
  const storeyIdArray = Array.from(storeyIds.values())
  if (storeyIdArray.length > 0) {
    createRelAggregates(ifcApi, modelID, ownerHistoryId, 'Building-Storeys', building.expressID, storeyIdArray)
  }

  return {
    projectId: project.expressID,
    siteId: site.expressID,
    buildingId: building.expressID,
    storeyIds
  }
}

/**
 * 벽 엔티티 생성
 */
function createWallEntity(
  ifcApi: WebIFC.IfcAPI,
  modelID: number,
  wall: MasterJSON['components']['walls'][number],
  hierarchy: IFCBuildingHierarchy,
  ownerHistoryId: number,
  contexts: GeometricContexts
): void {
  const ownerHistory = { type: 5, value: ownerHistoryId }

  // 좌표 변환 (mm -> m) - JSON의 z를 IFC의 y로 매핑 (평면도 좌표계 변환)
  const startX = wall.start.x * MM_TO_M
  const startY = (wall.start.z || 0) * MM_TO_M  // z → y (깊이를 평면 Y로)
  const startZ = (wall.start.y || 0) * MM_TO_M  // y → z (높이를 Z로)
  const endX = wall.end.x * MM_TO_M
  const endY = (wall.end.z || 0) * MM_TO_M  // z → y

  // 벽 치수 계산
  const dx = endX - startX
  const dy = endY - startY
  const length = Math.sqrt(dx * dx + dy * dy)
  const angle = Math.atan2(dy, dx)
  const height = (wall.height || DEFAULT_WALL_HEIGHT) * MM_TO_M
  const thickness = (wall.thickness || 150) * MM_TO_M

  // 해당 층 찾기
  const storeyId = hierarchy.storeyIds.get(wall.level) ||
                   Array.from(hierarchy.storeyIds.values())[0]

  // 벽 placement (벽 중심점에 배치)
  const centerX = (startX + endX) / 2
  const centerY = (startY + endY) / 2
  const wallPlacement = createLocalPlacementWithRotation(
    ifcApi, modelID, null, centerX, centerY, startZ, angle
  )

  // 사각형 프로파일 (길이 x 두께)
  const profile = createRectangleProfile(ifcApi, modelID, length, thickness)

  // 압출 방향 (Z축)
  const extrusionDir = createDirection(ifcApi, modelID, 0, 0, 1)

  // 압출 솔리드 생성
  const solid = ifcApi.CreateIfcEntity(
    modelID,
    IFCEXTRUDEDAREASOLID,
    profile,
    null, // Position (profile 위치)
    extrusionDir,
    ifcApi.CreateIfcType(modelID, IFCPOSITIVELENGTHMEASURE, height)
  )
  ifcApi.WriteLine(modelID, solid)

  // Shape representation
  const shapeRep = ifcApi.CreateIfcEntity(
    modelID,
    IFCSHAPEREPRESENTATION,
    { type: 5, value: contexts.bodyContext },
    ifcApi.CreateIfcType(modelID, IFCLABEL, 'Body'),
    ifcApi.CreateIfcType(modelID, IFCLABEL, 'SweptSolid'),
    [solid]
  )
  ifcApi.WriteLine(modelID, shapeRep)

  // Product definition shape
  const productShape = ifcApi.CreateIfcEntity(
    modelID,
    IFCPRODUCTDEFINITIONSHAPE,
    null, null,
    [shapeRep]
  )
  ifcApi.WriteLine(modelID, productShape)

  // Wall entity (IFCWALL 사용 - IFCWALLSTANDARDCASE는 재질 정보 필수로 deprecated됨)
  const wallEntity = ifcApi.CreateIfcEntity(
    modelID,
    IFCWALL,
    ifcApi.CreateIfcType(modelID, IFCGLOBALLYUNIQUEID, generateGUID()),
    ownerHistory,
    ifcApi.CreateIfcType(modelID, IFCLABEL, `Wall-${wall.id}`),
    null, null,
    wallPlacement,
    productShape,
    ifcApi.CreateIfcType(modelID, IFCIDENTIFIER, wall.id),
    { type: 3, value: 'NOTDEFINED' }  // STANDARD는 IFC4에서 deprecated (재질 정보 필수)
  )
  ifcApi.WriteLine(modelID, wallEntity)

  // 공간 포함 관계 생성
  createRelContainedInSpatialStructure(
    ifcApi, modelID, ownerHistoryId,
    `Wall-${wall.id}-Containment`,
    storeyId,
    [wallEntity.expressID]
  )
}

/**
 * 공간 엔티티 생성
 */
function createSpaceEntity(
  ifcApi: WebIFC.IfcAPI,
  modelID: number,
  space: MasterJSON['components']['spaces'][number],
  hierarchy: IFCBuildingHierarchy,
  ownerHistoryId: number,
  contexts: GeometricContexts
): void {
  const ownerHistory = { type: 5, value: ownerHistoryId }

  if (!space.boundary || space.boundary.length < 3) {
    console.warn(`Space ${space.id} has invalid boundary, skipping`)
    return
  }

  // 경계 좌표 변환 (mm -> m) 및 중복 점 제거 - JSON의 z를 IFC의 y로 매핑
  const rawPoints = space.boundary.map(p => ({
    x: p.x * MM_TO_M,
    y: (p.z || 0) * MM_TO_M,  // z → y (깊이를 평면 Y로)
    z: (p.y || 0) * MM_TO_M   // y → z (높이를 Z로)
  }))
  const boundaryPoints = cleanPolylinePoints(rawPoints)

  // 유효한 점이 부족한 경우 건너뜀
  if (boundaryPoints.length === 0) {
    console.warn(`Space ${space.id}: 유효한 점이 부족하여 건너뜀`)
    return
  }

  // 퇴화된 형상(면적 없음) 검증 - 닫기 점 제외하고 검사
  if (!isValidPolygon(boundaryPoints.slice(0, -1))) {
    console.warn(`Space ${space.id}: 퇴화된 형상(면적 없음)으로 건너뜀`)
    return
  }

  // 첫 번째 층 사용 (공간은 층 정보가 없을 수 있음)
  const storeyId = Array.from(hierarchy.storeyIds.values())[0]
  const baseZ = boundaryPoints[0]?.z || 0

  // Space placement
  const spacePlacement = createLocalPlacement(ifcApi, modelID, null, 0, 0, baseZ)

  // Polyline으로 경계 생성 (cleanPolylinePoints에서 이미 닫힘 처리됨)
  const polylinePoints = boundaryPoints.map(p =>
    createCartesianPoint(ifcApi, modelID, p.x, p.y, 0)
  )

  const polyline = ifcApi.CreateIfcEntity(
    modelID,
    IFCPOLYLINE,
    polylinePoints
  )
  ifcApi.WriteLine(modelID, polyline)

  // Arbitrary closed profile
  const profile = ifcApi.CreateIfcEntity(
    modelID,
    IFCARBITRARYCLOSEDPROFILEDEF,
    { type: 3, value: 'AREA' },
    ifcApi.CreateIfcType(modelID, IFCLABEL, `Space-${space.id}-Profile`),
    polyline
  )
  ifcApi.WriteLine(modelID, profile)

  // 압출 방향
  const extrusionDir = createDirection(ifcApi, modelID, 0, 0, 1)

  // 압출 솔리드
  const height = DEFAULT_SPACE_HEIGHT * MM_TO_M
  const solid = ifcApi.CreateIfcEntity(
    modelID,
    IFCEXTRUDEDAREASOLID,
    profile,
    null,
    extrusionDir,
    ifcApi.CreateIfcType(modelID, IFCPOSITIVELENGTHMEASURE, height)
  )
  ifcApi.WriteLine(modelID, solid)

  // Shape representation
  const shapeRep = ifcApi.CreateIfcEntity(
    modelID,
    IFCSHAPEREPRESENTATION,
    { type: 5, value: contexts.bodyContext },
    ifcApi.CreateIfcType(modelID, IFCLABEL, 'Body'),
    ifcApi.CreateIfcType(modelID, IFCLABEL, 'SweptSolid'),
    [solid]
  )
  ifcApi.WriteLine(modelID, shapeRep)

  // Product definition shape
  const productShape = ifcApi.CreateIfcEntity(
    modelID,
    IFCPRODUCTDEFINITIONSHAPE,
    null, null,
    [shapeRep]
  )
  ifcApi.WriteLine(modelID, productShape)

  // Space entity
  const spaceEntity = ifcApi.CreateIfcEntity(
    modelID,
    IFCSPACE,
    ifcApi.CreateIfcType(modelID, IFCGLOBALLYUNIQUEID, generateGUID()),
    ownerHistory,
    ifcApi.CreateIfcType(modelID, IFCLABEL, `${space.type || 'Space'}-${space.id}`),
    ifcApi.CreateIfcType(modelID, IFCTEXT, `Space type: ${space.type}`),
    null,
    spacePlacement,
    productShape,
    ifcApi.CreateIfcType(modelID, IFCLABEL, space.type || 'Room'),
    { type: 3, value: 'ELEMENT' },
    { type: 3, value: 'INTERNAL' }
  )
  ifcApi.WriteLine(modelID, spaceEntity)

  // 공간 포함 관계
  createRelContainedInSpatialStructure(
    ifcApi, modelID, ownerHistoryId,
    `Space-${space.id}-Containment`,
    storeyId,
    [spaceEntity.expressID]
  )
}

/**
 * 슬라브(바닥) 엔티티 생성
 */
function createSlabEntity(
  ifcApi: WebIFC.IfcAPI,
  modelID: number,
  slab: MasterJSON['components']['slabs'][number],
  hierarchy: IFCBuildingHierarchy,
  ownerHistoryId: number,
  contexts: GeometricContexts
): void {
  const ownerHistory = { type: 5, value: ownerHistoryId }

  if (!slab.footprint || slab.footprint.length < 3) {
    console.warn(`Slab ${slab.id} has invalid footprint, skipping`)
    return
  }

  // 경계 좌표 변환 (mm -> m) 및 중복 점 제거 - JSON의 z를 IFC의 y로 매핑
  const rawPoints = slab.footprint.map(p => ({
    x: p.x * MM_TO_M,
    y: (p.z || 0) * MM_TO_M,  // z → y (깊이를 평면 Y로)
    z: (p.y || 0) * MM_TO_M   // y → z (높이를 Z로)
  }))
  const footprintPoints = cleanPolylinePoints(rawPoints)

  // 유효한 점이 부족한 경우 건너뜀
  if (footprintPoints.length === 0) {
    console.warn(`Slab ${slab.id}: 유효한 점이 부족하여 건너뜀`)
    return
  }

  // 퇴화된 형상(면적 없음) 검증 - 닫기 점 제외하고 검사
  if (!isValidPolygon(footprintPoints.slice(0, -1))) {
    console.warn(`Slab ${slab.id}: 퇴화된 형상(면적 없음)으로 건너뜀`)
    return
  }

  // 해당 층 찾기
  const storeyId = hierarchy.storeyIds.get(slab.level) ||
                   Array.from(hierarchy.storeyIds.values())[0]

  // Slab placement
  const slabPlacement = createLocalPlacement(ifcApi, modelID, null, 0, 0, 0)

  // Polyline으로 footprint 생성 (cleanPolylinePoints에서 이미 닫힘 처리됨)
  const polylinePoints = footprintPoints.map(p =>
    createCartesianPoint(ifcApi, modelID, p.x, p.y, 0)
  )

  const polyline = ifcApi.CreateIfcEntity(
    modelID,
    IFCPOLYLINE,
    polylinePoints
  )
  ifcApi.WriteLine(modelID, polyline)

  // Arbitrary closed profile
  const profile = ifcApi.CreateIfcEntity(
    modelID,
    IFCARBITRARYCLOSEDPROFILEDEF,
    { type: 3, value: 'AREA' },
    ifcApi.CreateIfcType(modelID, IFCLABEL, `Slab-${slab.id}-Profile`),
    polyline
  )
  ifcApi.WriteLine(modelID, profile)

  // 압출 방향 (아래로)
  const extrusionDir = createDirection(ifcApi, modelID, 0, 0, -1)

  // 슬라브 두께
  const thickness = (slab.thickness || DEFAULT_SLAB_THICKNESS) * MM_TO_M

  // 압출 솔리드
  const solid = ifcApi.CreateIfcEntity(
    modelID,
    IFCEXTRUDEDAREASOLID,
    profile,
    null,
    extrusionDir,
    ifcApi.CreateIfcType(modelID, IFCPOSITIVELENGTHMEASURE, thickness)
  )
  ifcApi.WriteLine(modelID, solid)

  // Shape representation
  const shapeRep = ifcApi.CreateIfcEntity(
    modelID,
    IFCSHAPEREPRESENTATION,
    { type: 5, value: contexts.bodyContext },
    ifcApi.CreateIfcType(modelID, IFCLABEL, 'Body'),
    ifcApi.CreateIfcType(modelID, IFCLABEL, 'SweptSolid'),
    [solid]
  )
  ifcApi.WriteLine(modelID, shapeRep)

  // Product definition shape
  const productShape = ifcApi.CreateIfcEntity(
    modelID,
    IFCPRODUCTDEFINITIONSHAPE,
    null, null,
    [shapeRep]
  )
  ifcApi.WriteLine(modelID, productShape)

  // Slab entity
  const slabEntity = ifcApi.CreateIfcEntity(
    modelID,
    IFCSLAB,
    ifcApi.CreateIfcType(modelID, IFCGLOBALLYUNIQUEID, generateGUID()),
    ownerHistory,
    ifcApi.CreateIfcType(modelID, IFCLABEL, `Slab-${slab.id}`),
    null, null,
    slabPlacement,
    productShape,
    ifcApi.CreateIfcType(modelID, IFCIDENTIFIER, slab.id),
    { type: 3, value: 'FLOOR' }
  )
  ifcApi.WriteLine(modelID, slabEntity)

  // 공간 포함 관계
  createRelContainedInSpatialStructure(
    ifcApi, modelID, ownerHistoryId,
    `Slab-${slab.id}-Containment`,
    storeyId,
    [slabEntity.expressID]
  )
}

/**
 * 문 엔티티 생성
 */
function createDoorEntity(
  ifcApi: WebIFC.IfcAPI,
  modelID: number,
  door: MasterJSON['components']['openings']['doors'][number],
  hierarchy: IFCBuildingHierarchy,
  ownerHistoryId: number,
  contexts: GeometricContexts
): void {
  const ownerHistory = { type: 5, value: ownerHistoryId }

  // 좌표 변환 (mm -> m)
  const posX = door.position.x * MM_TO_M
  const posY = door.position.y * MM_TO_M
  const posZ = (door.position.z || 0) * MM_TO_M
  const width = door.width * MM_TO_M
  const height = door.height * MM_TO_M
  const depth = 0.1 // 문 두께 10cm

  // 첫 번째 층 사용
  const storeyId = Array.from(hierarchy.storeyIds.values())[0]

  // Door placement
  const doorPlacement = createLocalPlacement(ifcApi, modelID, null, posX, posY, posZ)

  // 사각형 프로파일
  const profile = createRectangleProfile(ifcApi, modelID, width, depth)

  // 압출 방향
  const extrusionDir = createDirection(ifcApi, modelID, 0, 0, 1)

  // 압출 솔리드
  const solid = ifcApi.CreateIfcEntity(
    modelID,
    IFCEXTRUDEDAREASOLID,
    profile,
    null,
    extrusionDir,
    ifcApi.CreateIfcType(modelID, IFCPOSITIVELENGTHMEASURE, height)
  )
  ifcApi.WriteLine(modelID, solid)

  // Shape representation
  const shapeRep = ifcApi.CreateIfcEntity(
    modelID,
    IFCSHAPEREPRESENTATION,
    { type: 5, value: contexts.bodyContext },
    ifcApi.CreateIfcType(modelID, IFCLABEL, 'Body'),
    ifcApi.CreateIfcType(modelID, IFCLABEL, 'SweptSolid'),
    [solid]
  )
  ifcApi.WriteLine(modelID, shapeRep)

  // Product definition shape
  const productShape = ifcApi.CreateIfcEntity(
    modelID,
    IFCPRODUCTDEFINITIONSHAPE,
    null, null,
    [shapeRep]
  )
  ifcApi.WriteLine(modelID, productShape)

  // Door entity
  const doorEntity = ifcApi.CreateIfcEntity(
    modelID,
    IFCDOOR,
    ifcApi.CreateIfcType(modelID, IFCGLOBALLYUNIQUEID, generateGUID()),
    ownerHistory,
    ifcApi.CreateIfcType(modelID, IFCLABEL, `Door-${door.id}`),
    null, null,
    doorPlacement,
    productShape,
    ifcApi.CreateIfcType(modelID, IFCIDENTIFIER, door.id),
    ifcApi.CreateIfcType(modelID, IFCPOSITIVELENGTHMEASURE, height),
    ifcApi.CreateIfcType(modelID, IFCPOSITIVELENGTHMEASURE, width),
    { type: 3, value: 'DOOR' },
    { type: 3, value: 'SINGLE_SWING_LEFT' },
    null
  )
  ifcApi.WriteLine(modelID, doorEntity)

  // 공간 포함 관계
  createRelContainedInSpatialStructure(
    ifcApi, modelID, ownerHistoryId,
    `Door-${door.id}-Containment`,
    storeyId,
    [doorEntity.expressID]
  )
}

/**
 * 창문 엔티티 생성
 */
function createWindowEntity(
  ifcApi: WebIFC.IfcAPI,
  modelID: number,
  window: MasterJSON['components']['openings']['windows'][number],
  hierarchy: IFCBuildingHierarchy,
  ownerHistoryId: number,
  contexts: GeometricContexts
): void {
  const ownerHistory = { type: 5, value: ownerHistoryId }

  // 좌표 변환 (mm -> m)
  const posX = window.position.x * MM_TO_M
  const posY = window.position.y * MM_TO_M
  const sillHeight = (window.sillHeight || 900) * MM_TO_M
  const posZ = (window.position.z || 0) * MM_TO_M + sillHeight
  const width = window.width * MM_TO_M
  const height = window.height * MM_TO_M
  const depth = 0.05 // 창문 두께 5cm

  // 첫 번째 층 사용
  const storeyId = Array.from(hierarchy.storeyIds.values())[0]

  // Window placement
  const windowPlacement = createLocalPlacement(ifcApi, modelID, null, posX, posY, posZ)

  // 사각형 프로파일
  const profile = createRectangleProfile(ifcApi, modelID, width, depth)

  // 압출 방향
  const extrusionDir = createDirection(ifcApi, modelID, 0, 0, 1)

  // 압출 솔리드
  const solid = ifcApi.CreateIfcEntity(
    modelID,
    IFCEXTRUDEDAREASOLID,
    profile,
    null,
    extrusionDir,
    ifcApi.CreateIfcType(modelID, IFCPOSITIVELENGTHMEASURE, height)
  )
  ifcApi.WriteLine(modelID, solid)

  // Shape representation
  const shapeRep = ifcApi.CreateIfcEntity(
    modelID,
    IFCSHAPEREPRESENTATION,
    { type: 5, value: contexts.bodyContext },
    ifcApi.CreateIfcType(modelID, IFCLABEL, 'Body'),
    ifcApi.CreateIfcType(modelID, IFCLABEL, 'SweptSolid'),
    [solid]
  )
  ifcApi.WriteLine(modelID, shapeRep)

  // Product definition shape
  const productShape = ifcApi.CreateIfcEntity(
    modelID,
    IFCPRODUCTDEFINITIONSHAPE,
    null, null,
    [shapeRep]
  )
  ifcApi.WriteLine(modelID, productShape)

  // Window entity
  const windowEntity = ifcApi.CreateIfcEntity(
    modelID,
    IFCWINDOW,
    ifcApi.CreateIfcType(modelID, IFCGLOBALLYUNIQUEID, generateGUID()),
    ownerHistory,
    ifcApi.CreateIfcType(modelID, IFCLABEL, `Window-${window.id}`),
    null, null,
    windowPlacement,
    productShape,
    ifcApi.CreateIfcType(modelID, IFCIDENTIFIER, window.id),
    ifcApi.CreateIfcType(modelID, IFCPOSITIVELENGTHMEASURE, height),
    ifcApi.CreateIfcType(modelID, IFCPOSITIVELENGTHMEASURE, width),
    { type: 3, value: 'WINDOW' },
    { type: 3, value: 'SINGLE_PANEL' },
    null
  )
  ifcApi.WriteLine(modelID, windowEntity)

  // 공간 포함 관계
  createRelContainedInSpatialStructure(
    ifcApi, modelID, ownerHistoryId,
    `Window-${window.id}-Containment`,
    storeyId,
    [windowEntity.expressID]
  )
}

// ==================== Polyline Helpers ====================

/**
 * 폴리곤이 유효한 2D 면적을 가지는지 확인
 * 모든 점이 일직선 상에 있으면 false (퇴화된 형상)
 * @param points 폴리곤 점 배열 (닫기 점 제외)
 * @returns 유효 여부
 */
function isValidPolygon(points: Array<{ x: number; y: number }>): boolean {
  if (points.length < 3) return false

  // 면적 계산 (Shoelace formula)
  let area = 0
  for (let i = 0; i < points.length; i++) {
    const j = (i + 1) % points.length
    area += points[i].x * points[j].y
    area -= points[j].x * points[i].y
  }
  area = Math.abs(area) / 2

  // 면적이 최소 0.0001 m² (10cm x 10cm) 이상이어야 유효
  return area > 0.0001
}

/**
 * 중복 점 제거 및 유효한 폴리라인 생성
 * - 좌표를 1mm 단위로 반올림하여 부동소수점 오차 제거
 * - 연속 중복 점 제거
 * - 퇴화된 형상(점 3개 미만) 감지
 * @param points 원본 점 배열
 * @param precision 좌표 반올림 단위 (기본값: 0.001m = 1mm)
 * @returns 정리된 점 배열 (유효하지 않으면 빈 배열)
 */
function cleanPolylinePoints(
  points: Array<{ x: number; y: number; z?: number }>,
  precision: number = 0.001
): Array<{ x: number; y: number; z: number }> {
  if (points.length < 3) return []

  // 1. 좌표 반올림 (부동소수점 오차 제거)
  const rounded = points.map(p => ({
    x: Math.round(p.x / precision) * precision,
    y: Math.round(p.y / precision) * precision,
    z: Math.round((p.z || 0) / precision) * precision
  }))

  // 2. 연속 중복 제거
  const result: Array<{ x: number; y: number; z: number }> = []
  for (const current of rounded) {
    const prev = result[result.length - 1]
    if (!prev || prev.x !== current.x || prev.y !== current.y || prev.z !== current.z) {
      result.push(current)
    }
  }

  // 3. 마지막 점이 첫 점과 같으면 제거 (닫기는 나중에)
  if (result.length >= 2) {
    const first = result[0]
    const last = result[result.length - 1]
    if (first.x === last.x && first.y === last.y && first.z === last.z) {
      result.pop()
    }
  }

  // 4. 최소 3점 필요 (삼각형)
  if (result.length < 3) {
    return []
  }

  // 5. 닫힌 폴리라인으로 만들기
  result.push({ ...result[0] })

  return result
}

// ==================== Geometry Helpers ====================

/**
 * CartesianPoint 생성
 */
function createCartesianPoint(
  ifcApi: WebIFC.IfcAPI,
  modelID: number,
  x: number,
  y: number,
  z: number
): any {
  const point = ifcApi.CreateIfcEntity(
    modelID,
    IFCCARTESIANPOINT,
    [
      ifcApi.CreateIfcType(modelID, IFCLENGTHMEASURE, x),
      ifcApi.CreateIfcType(modelID, IFCLENGTHMEASURE, y),
      ifcApi.CreateIfcType(modelID, IFCLENGTHMEASURE, z)
    ]
  )
  ifcApi.WriteLine(modelID, point)
  return point
}

/**
 * Direction 생성
 */
function createDirection(
  ifcApi: WebIFC.IfcAPI,
  modelID: number,
  x: number,
  y: number,
  z: number
): any {
  const direction = ifcApi.CreateIfcEntity(
    modelID,
    IFCDIRECTION,
    [
      ifcApi.CreateIfcType(modelID, IFCREAL, x),
      ifcApi.CreateIfcType(modelID, IFCREAL, y),
      ifcApi.CreateIfcType(modelID, IFCREAL, z)
    ]
  )
  ifcApi.WriteLine(modelID, direction)
  return direction
}

/**
 * LocalPlacement 생성
 */
function createLocalPlacement(
  ifcApi: WebIFC.IfcAPI,
  modelID: number,
  relativeTo: any | null,
  x: number,
  y: number,
  z: number
): any {
  const origin = createCartesianPoint(ifcApi, modelID, x, y, z)
  const zAxis = createDirection(ifcApi, modelID, 0, 0, 1)
  const xAxis = createDirection(ifcApi, modelID, 1, 0, 0)

  const axis2Placement = ifcApi.CreateIfcEntity(
    modelID,
    IFCAXIS2PLACEMENT3D,
    origin,
    zAxis,
    xAxis
  )
  ifcApi.WriteLine(modelID, axis2Placement)

  const localPlacement = ifcApi.CreateIfcEntity(
    modelID,
    IFCLOCALPLACEMENT,
    relativeTo,
    axis2Placement
  )
  ifcApi.WriteLine(modelID, localPlacement)

  return localPlacement
}

/**
 * 회전이 포함된 LocalPlacement 생성
 */
function createLocalPlacementWithRotation(
  ifcApi: WebIFC.IfcAPI,
  modelID: number,
  relativeTo: any | null,
  x: number,
  y: number,
  z: number,
  rotationAngle: number
): any {
  const origin = createCartesianPoint(ifcApi, modelID, x, y, z)
  const zAxis = createDirection(ifcApi, modelID, 0, 0, 1)

  // X축을 회전 각도에 따라 조정
  const xAxis = createDirection(
    ifcApi, modelID,
    Math.cos(rotationAngle),
    Math.sin(rotationAngle),
    0
  )

  const axis2Placement = ifcApi.CreateIfcEntity(
    modelID,
    IFCAXIS2PLACEMENT3D,
    origin,
    zAxis,
    xAxis
  )
  ifcApi.WriteLine(modelID, axis2Placement)

  const localPlacement = ifcApi.CreateIfcEntity(
    modelID,
    IFCLOCALPLACEMENT,
    relativeTo,
    axis2Placement
  )
  ifcApi.WriteLine(modelID, localPlacement)

  return localPlacement
}

/**
 * 사각형 프로파일 생성
 */
function createRectangleProfile(
  ifcApi: WebIFC.IfcAPI,
  modelID: number,
  xDim: number,
  yDim: number
): any {
  const profile = ifcApi.CreateIfcEntity(
    modelID,
    IFCRECTANGLEPROFILEDEF,
    { type: 3, value: 'AREA' },
    ifcApi.CreateIfcType(modelID, IFCLABEL, 'RectangleProfile'),
    null, // Position (centered at origin)
    ifcApi.CreateIfcType(modelID, IFCPOSITIVELENGTHMEASURE, xDim),
    ifcApi.CreateIfcType(modelID, IFCPOSITIVELENGTHMEASURE, yDim)
  )
  ifcApi.WriteLine(modelID, profile)
  return profile
}

// ==================== Relationship Helpers ====================

/**
 * RelAggregates 관계 생성
 */
function createRelAggregates(
  ifcApi: WebIFC.IfcAPI,
  modelID: number,
  ownerHistoryId: number,
  name: string,
  relatingId: number,
  relatedIds: number[]
): void {
  const relAggregates = ifcApi.CreateIfcEntity(
    modelID,
    IFCRELAGGREGATES,
    ifcApi.CreateIfcType(modelID, IFCGLOBALLYUNIQUEID, generateGUID()),
    { type: 5, value: ownerHistoryId },
    ifcApi.CreateIfcType(modelID, IFCLABEL, name),
    null,
    { type: 5, value: relatingId },
    relatedIds.map(id => ({ type: 5, value: id }))
  )
  ifcApi.WriteLine(modelID, relAggregates)
}

/**
 * RelContainedInSpatialStructure 관계 생성
 */
function createRelContainedInSpatialStructure(
  ifcApi: WebIFC.IfcAPI,
  modelID: number,
  ownerHistoryId: number,
  name: string,
  relatingStructureId: number,
  relatedElementIds: number[]
): void {
  const relContained = ifcApi.CreateIfcEntity(
    modelID,
    IFCRELCONTAINEDINSPATIALSTRUCTURE,
    ifcApi.CreateIfcType(modelID, IFCGLOBALLYUNIQUEID, generateGUID()),
    { type: 5, value: ownerHistoryId },
    ifcApi.CreateIfcType(modelID, IFCLABEL, name),
    null,
    relatedElementIds.map(id => ({ type: 5, value: id })),
    { type: 5, value: relatingStructureId }
  )
  ifcApi.WriteLine(modelID, relContained)
}

// ==================== Utility Functions ====================

/**
 * IFC GUID 생성 (Base64 인코딩된 22자 문자열)
 */
function generateGUID(): string {
  // UUID v4 생성
  const uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0
    const v = c === 'x' ? r : (r & 0x3 | 0x8)
    return v.toString(16)
  })

  // UUID를 IFC GUID 형식으로 변환 (Base64)
  const hex = uuid.replace(/-/g, '')
  const bytes = new Uint8Array(16)
  for (let i = 0; i < 16; i++) {
    bytes[i] = parseInt(hex.substr(i * 2, 2), 16)
  }

  // IFC Base64 문자셋 (표준 Base64와 다름)
  const base64Chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_$'
  let result = ''

  // 128비트를 22개의 6비트 그룹으로 변환
  let bitBuffer = 0
  let bitCount = 0

  for (let i = 0; i < 16; i++) {
    bitBuffer = (bitBuffer << 8) | bytes[i]
    bitCount += 8

    while (bitCount >= 6) {
      bitCount -= 6
      const index = (bitBuffer >> bitCount) & 0x3F
      result += base64Chars[index]
    }
  }

  // 남은 비트 처리
  if (bitCount > 0) {
    const index = (bitBuffer << (6 - bitCount)) & 0x3F
    result += base64Chars[index]
  }

  return result.substring(0, 22)
}

/**
 * IFC 파일 다운로드
 */
function downloadIfcFile(data: Uint8Array, filename: string): void {
  // Uint8Array를 새 Uint8Array로 복사하여 Blob 생성 (타입 호환성 보장)
  const copyData = new Uint8Array(data)
  const blob = new Blob([copyData], { type: 'application/x-step' })
  const url = URL.createObjectURL(blob)
  const link = document.createElement('a')
  link.href = url
  link.download = filename
  document.body.appendChild(link)
  link.click()
  document.body.removeChild(link)
  URL.revokeObjectURL(url)
}
